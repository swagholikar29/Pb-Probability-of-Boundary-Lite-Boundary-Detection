# -*- coding: utf-8 -*-
"""RBE549_Final_phase1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16jwv4Ag4nSzwPKqvjBBICv1GlrIFiba_
"""

!wget https://raw.githubusercontent.com/leelening/rbe549/main/hw0/BSDS500.tar.xz
!tar -xvf BSDS500.tar.xz
!mv BSDS500/ /content/data/

!wget https://raw.githubusercontent.com/leelening/rbe549/main/hw0/TxtFiles.tar.xz
!tar -xvf TxtFiles.tar.xz
!mv TxtFiles/ /content/data/

import numpy as np
import cv2
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from scipy.ndimage import convolve, rotate
import os
import glob
import imutils
import math

#Generate Gaussian filter (Refer formula wikipedia)
def Gen_Gaussian(Size, SigmaX, SigmaY):
    x, y = np.mgrid[-Size/2:Size/2+1, -Size/2:Size/2+1]
    GaussianFilter = np.exp(-(x**2/(2 * SigmaX**2) + y ** 2/(2 * SigmaY**2)))/(2 * math.pi * SigmaX*SigmaY)

    return GaussianFilter

#First derivative of Gaussian
def Gen_DoGFilter(Size, SigmaX, SigmaY, Orientation):
    SobelX = np.array([
        [-1, 0, 1],
        [-2, 0, 2],
        [-1, 0, 1]])/8
    SobelY = np.transpose(SobelX)

    GaussianFilter = Gen_Gaussian(Size, SigmaX, SigmaY)
    DoGFilter = convolve(GaussianFilter, SobelY)
    OrientedDoGFilter = rotate(DoGFilter, Orientation)

    return OrientedDoGFilter

#Second derivative of Gaussian
def Gen_SecondDoGFilter(Size, SigmaX, SigmaY, Orientation):
    SobelX = np.array([
        [-1, 0, 1],
        [-2, 0, 2],
        [-1, 0, 1]])/8
    SobelY = np.transpose(SobelX)

    DoGFilter = Gen_DoGFilter(Size, SigmaX, SigmaY, Orientation)
    SecondDoGFilter = convolve(DoGFilter, SobelY)
    OrientedSecondDoGFilter = rotate(SecondDoGFilter, Orientation)
    return OrientedSecondDoGFilter


def LaplacianOfGaussian(Size, SigmaX, SigmaY):
    LaplacianNegative = np.array([
        [0, 1, 0],
        [1, -4, 1],
        [0, 1, 0]])

    GaussianFilter = Gen_Gaussian(Size, SigmaX, SigmaY)
    LoGFilter = convolve(GaussianFilter, LaplacianNegative)
    return LoGFilter

#for gradient
def CreateBinary(Img, Bins):
	BinaryImg = Img * 0
	for a in range(0, Img.shape[0]):
		for b in range(0, Img.shape[1]):
			if Img[a, b] == Bins:
				BinaryImg[a, b] = 1
			else:
				BinaryImg[a, b] = 0
	return BinaryImg


def Gradient(Maps, Bins, m1, m2):
	Maps = Maps.astype(np.float64)
	gradient = np.zeros((Maps.shape[0], Maps.shape[1], 12))
	for m in range(0, 12):
		chi_sq = np.zeros((Maps.shape))
		for i in range(1, Bins):
			tmp = CreateBinary(Maps, i)
			a = cv2.filter2D(tmp, -1, m1[m]) #!!convolve not working here!!
			b = cv2.filter2D(tmp, -1,  m2[m])
			chi_sq = chi_sq + ((a - b) ** 2) / (a + b + 0.0001)
		gradient[:, :, m] = chi_sq

	return gradient


#For half disc
def HalfDisc(r):
  hd = np.zeros((r*2,r*2))
  for i in range(0,r):
    m = (i-r)**2
    for j in range(0,2*r):
      if m+(j-r)**2 < r**2:
        hd[i,j] =1
  return hd


#Filters.
def OrientedDoG():

  Size=64
  Scales=[4,8]
  Orientations=16

  Sobel_x = np.array([
      [-1, 0, 1],
      [-2, 0, 2], 
      [-1, 0, 1]])
  Sobel_y = np.array([
      [1, 2, 1],
      [0, 0, 0], 
      [-1, -2, -1]])
  
  DoGFilter = []
  
  for s in Scales :
    gaussian_kernel = Gen_Gaussian(Size, s, s)
    
    DoGaussian_x = convolve(gaussian_kernel, Sobel_x)
    DoGaussian_y = convolve(gaussian_kernel, Sobel_y)

    DoGaussian= 0.5*DoGaussian_x+0.5*DoGaussian_y

    for o in range(Orientations):
      f = rotate(DoGaussian,o*360.0/Orientations)
      DoGFilter.append(f)

  fig, ax = plt.subplots(2,16,figsize=(16,16))

  for i in range(2):
    for j in range(16):
      ax[i][j].imshow(DoGFilter[(i*16)+j], cmap='gray')
      ax[i][j].set_axis_off()
  fig.tight_layout(h_pad=-50)
  plt.show()
	
  return DoGFilter

#Leung-Malik
def LMSFilter(Size):
    LMSFilter = []
    Orientations = 6
    Scales = [1, math.sqrt(2), 2, 2*math.sqrt(2)] #!!!imp check

    for s in Scales:
        LMSFilter.append(Gen_Gaussian(Size, s, s))
        LMSFilter.append(LaplacianOfGaussian(Size, s, s))
        LMSFilter.append(LaplacianOfGaussian(Size, 3*s, 3*s)) #two sigmas
        for o in range(Orientations):
            LMSFilter.append(Gen_DoGFilter(Size, s, 3*s, o*360/Orientations))
            LMSFilter.append(Gen_SecondDoGFilter(Size, s, 3*s, o*360/Orientations))
            
    fig, ax = plt.subplots(4,12,figsize=(16,16))
            
    for i in range(4):
      for j in range(12):
        ax[i][j].imshow(LMSFilter[(i*16)+j], cmap='gray')
        ax[i][j].set_axis_off()
      fig.tight_layout(h_pad=-20)
    plt.show()
    
    return LMSFilter


def LMLFilter(Size):
    LMLFilter= []
    Orientations = 6
    Scales = [math.sqrt(2), 2, 2*math.sqrt(2), 4] #imp!!! check

    for s in Scales:
        LMLFilter.append(Gen_Gaussian(Size, s, s))
        LMLFilter.append(LaplacianOfGaussian(Size, s, s))
        LMLFilter.append(LaplacianOfGaussian(Size, 3*s, 3*s)) #two sigmas
        for o in range(Orientations):
            LMLFilter.append(Gen_DoGFilter(Size, s, 3*s, o*360/Orientations))
            LMLFilter.append(Gen_SecondDoGFilter(Size, s, 3*s, o*360/Orientations))          

    fig, ax = plt.subplots(4,12,figsize=(16,16))
            
    for i in range(4):
      for j in range(12):
        ax[i][j].imshow(LMLFilter[(i*16)+j], cmap='gray')
        ax[i][j].set_axis_off()
      fig.tight_layout(h_pad=-20)
    plt.show()

    return LMLFilter


#Gabor filter Refered from wikipedia
def Gabor():
  Sigma = [3,5,7,9,11]
  Theta = [np.pi*i/4 for i in range(8)]
  Lambda=5
  Psi=0
  Gamma=1
  gbFilter=[]
  for i in range(len(Sigma)):
    for j in range(len(Theta)):
      SigmaX = Sigma[i]
      SigmaY = Sigma[i]/Gamma

      nstds = 2.5 
      xmax = max(abs(nstds * SigmaX * np.cos(Theta[j])), abs(nstds * SigmaY * np.sin(Theta[j])))
      xmax = np.ceil(max(1, xmax))
      ymax = max(abs(nstds * SigmaX * np.sin(Theta[j])), abs(nstds * SigmaY * np.cos(Theta[j])))
      ymax = np.ceil(max(1, ymax))
      xmin = -xmax
      ymin = -ymax
      (y, x) = np.meshgrid(np.arange(ymin, ymax + 1), np.arange(xmin, xmax + 1))

      ThetaX = x * np.cos(Theta[j]) + y * np.sin(Theta[j])
      ThetaY = -x * np.sin(Theta[j]) + y * np.cos(Theta[j])

      gb = np.exp(-.5 * (ThetaX ** 2 / SigmaX ** 2 + ThetaY ** 2 / SigmaY ** 2)) * np.cos(2 * np.pi / Lambda * ThetaY + Psi)
      gbFilter.append(gb)

  fig, ax = plt.subplots(5,8, figsize=(12,12))
  
  for i in range(5):
    for j in range(8):
      ax[i][j].imshow(gbFilter[(i*8)+j], cmap='gray')
      ax[i][j].set_axis_off()
    fig.tight_layout(h_pad=-7)
  plt.show(block=False)

  return gbFilter

def main():
  #initiate filters
	DoG = OrientedDoG()
	L1 = LMSFilter(48)
	L2 = LMLFilter(48)
	G = Gabor()
 
  #Half discs
	Orientation = np.arange(0, 360, 360 / 8)
	Scales = np.asarray([5, 7, 10])
	m3 = []
	m4 = []

	for i in range(0, Scales.size):
		hd = HalfDisc(Scales[i])
		for m in range(0, Orientation.size):
			m1 = rotate(hd, Orientation[m])
			m3.append(m1)
			m2 = rotate(m1, 180)
			m4.append(m2)
			plt.subplot(Scales.size * 2, Orientation.size, Orientation.size * 2 * (i) + m + 1)
			plt.axis('off')
			plt.imshow(m1, cmap='gray')
			plt.subplot(Scales.size * 2, Orientation.size, Orientation.size * 2 * (i) + m + 1 + Orientation.size)
			plt.axis('off')
			plt.imshow(m2, cmap='gray')
	plt.show()

	#append all filter banks
	FilterBank = []
	for i in range(0, len(DoG)):
		FilterBank.append(DoG[i])

	for i in range(0, 48):
		FilterBank.append(L1[i])
		FilterBank.append(L2[i])

	for i in range(len(G)):
		FilterBank.append(G[i])
  
  #Load the images
	os.chdir("/content/data/Images")

	Images = []
	for img in sorted(glob.glob("*.jpg")):
		img_ = cv2.imread(img)
		Images.append(img_)

	ImageNo = 7 #Will range from 0-9.
	plt.imshow(cv2.cvtColor(Images[ImageNo], cv2.COLOR_BGR2RGB))
	plt.show()

	Img = cv2.cvtColor(Images[ImageNo], cv2.COLOR_BGR2GRAY) #grayscale image for brightness map
	ImgCurr = Images[ImageNo] #colored image for color map

  #Texton map and gradient calculation
	data = np.zeros((Img.size, len(FilterBank)))
	for i in range(0, len(FilterBank)):
		temp = convolve(Img, FilterBank[i])
		temp = temp.reshape((1, Img.size))
		data[:, i] = temp
	Kmeans_texton = KMeans(n_clusters=64, n_init=4)
	Kmeans_texton.fit(data)
	labels = Kmeans_texton.labels_
	TextonMap = np.reshape(labels, (Img.shape))
	plt.imshow(TextonMap, cmap=None)
	plt.title("TextonMap")
	plt.axis('off')
	plt.show()
	texton_gradient = Gradient(TextonMap, 64, m1, m2)
	tg = np.mean(texton_gradient, axis=2)
	plt.imshow(tg, cmap=None)
	plt.title("TextonGradient")
	plt.axis('off')
	plt.show()

  #brightness map and gradient calculation
	m = Img.reshape((Img.shape[0] * Img.shape[1]), 1) #1 color channel
  #print(m)
	Kmeans_brightness = KMeans(n_clusters=16, random_state=4)
	Kmeans_brightness.fit(m)
	labels = Kmeans_brightness.labels_
	BrightnessMap = np.reshape(labels, (Img.shape[0], Img.shape[1]))
	BrightnessMapF = 255 * (BrightnessMap - np.min(BrightnessMap)) / np.float((np.max(BrightnessMap) - np.min(BrightnessMap)))
	plt.imshow(BrightnessMapF, cmap=None)
	plt.title("BrightnessMap")
	plt.axis('off')
	plt.show()
	bright_gradient = Gradient(BrightnessMap, 16, m1, m2)
	bg = np.mean(bright_gradient, axis=2)
	plt.imshow(bg, cmap=None)
	plt.title("BrightnessGradient")
	plt.axis('off')
	plt.show()
 
  #color map and gradient calculation
	m = ImgCurr.reshape((ImgCurr.shape[0] * ImgCurr.shape[1]), 3) #3 color channels
  #print(m)
	Kmeans_color = KMeans(n_clusters=16, random_state=4)
	Kmeans_color.fit(m)
	labels = Kmeans_color.labels_
	ColorMap = np.reshape(labels, (Img.shape[0], Img.shape[1]))
	plt.imshow(ColorMap)
	plt.title("ColorMap")
	plt.axis('off')
	plt.show()
	color_gradient = Gradient(ColorMap, 16, m1, m2)
	cg = np.mean(color_gradient, axis=2)
	plt.imshow(cg)
	plt.title("ColorGradient")
	plt.axis('off')
	plt.show()

	os.chdir("/content/data/SobelBaseline")
	s = cv2.imread("{}.png".format(ImageNo))
	plt.imshow(s)
	plt.axis('off')
	plt.show()


	os.chdir("/content/data/CannyBaseline")
	c = cv2.imread("{}.png".format(ImageNo))
	plt.imshow(c)
	plt.axis('off')
	plt.show()

	sm = cv2.cvtColor(s, cv2.COLOR_BGR2GRAY) #convert to grayscale
	cm = cv2.cvtColor(c, cv2.COLOR_BGR2GRAY)

	Avg_ = (tg + bg + cg) / 3
	pb = Avg_ * (0.9 * cm + 0.1 * sm) #w1 and w2 adjust

	plt.imshow(pb, cmap="gray")
	plt.axis('off')
	plt.show()
    
if __name__ == '__main__':
    main()